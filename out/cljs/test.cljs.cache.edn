{:rename-macros {}, :renames {}, :externs {Error {}, parseInt {}}, :use-macros {}, :excludes #{}, :name cljs.test, :imports nil, :requires {string clojure.string, clojure.string clojure.string, pprint cljs.pprint, cljs.pprint cljs.pprint}, :cljs.spec/speced-vars [], :uses nil, :defs {default-fixture {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 495, :column 8, :end-line 495, :end-column 23, :private true, :arglists (quote ([f])), :doc "The default, empty, fixture function.  Just calls its argument.\n\n  NOTE: Incompatible with map fixtures."}, :private true, :name cljs.test/default-fixture, :variadic false, :file "out/cljs/test.cljs", :end-column 23, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 495, :end-line 495, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "The default, empty, fixture function.  Just calls its argument.\n\n  NOTE: Incompatible with map fixtures."}, test-var {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 489, :column 7, :end-line 489, :end-column 15, :arglists (quote ([v])), :doc "If v has a function in its :test metadata, calls that function,\n  add v to :testing-vars property of env."}, :name cljs.test/test-var, :variadic false, :file "out/cljs/test.cljs", :end-column 15, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 489, :end-line 489, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "If v has a function in its :test metadata, calls that function,\n  add v to :testing-vars property of env."}, execution-strategy {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 525, :column 8, :end-line 525, :end-column 26, :private true, :arglists (quote ([once each]))}, :private true, :name cljs.test/execution-strategy, :variadic false, :file "out/cljs/test.cljs", :end-column 26, :method-params ([once each]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 525, :end-line 525, :max-fixed-arity 2, :fn-var true, :arglists (quote ([once each]))}, do-report {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 413, :column 7, :end-line 413, :end-column 16, :arglists (quote ([m]))}, :name cljs.test/do-report, :variadic false, :file "out/cljs/test.cljs", :end-column 16, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 413, :end-line 413, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m]))}, async? {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 427, :column 7, :end-line 427, :end-column 13, :arglists (quote ([x])), :doc "Returns whether x implements IAsyncTest."}, :name cljs.test/async?, :variadic false, :file "out/cljs/test.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 427, :end-line 427, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns whether x implements IAsyncTest."}, testing-contexts-str {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 299, :column 7, :end-line 299, :end-column 27, :arglists (quote ([])), :doc "Returns a string representation of the current test context. Joins\n  strings in *testing-contexts* with spaces."}, :name cljs.test/testing-contexts-str, :variadic false, :file "out/cljs/test.cljs", :end-column 27, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 299, :end-line 299, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Returns a string representation of the current test context. Joins\n  strings in *testing-contexts* with spaces."}, join-fixtures {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 510, :column 7, :end-line 510, :end-column 20, :arglists (quote ([fixtures])), :doc "Composes a collection of fixtures, in order.  Always returns a valid\n  fixture function, even if the collection is empty.\n\n  NOTE: Incompatible with map fixtures."}, :name cljs.test/join-fixtures, :variadic false, :file "out/cljs/test.cljs", :end-column 20, :method-params ([fixtures]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 510, :end-line 510, :max-fixed-arity 1, :fn-var true, :arglists (quote ([fixtures])), :doc "Composes a collection of fixtures, in order.  Always returns a valid\n  fixture function, even if the collection is empty.\n\n  NOTE: Incompatible with map fixtures."}, inc-report-counter! {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 305, :column 7, :end-line 305, :end-column 26, :arglists (quote ([name])), :doc "Increments the named counter in *report-counters*, a ref to a map.\n  Does nothing if *report-counters* is nil."}, :name cljs.test/inc-report-counter!, :variadic false, :file "out/cljs/test.cljs", :end-column 26, :method-params ([name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 305, :end-line 305, :max-fixed-arity 1, :fn-var true, :arglists (quote ([name])), :doc "Increments the named counter in *report-counters*, a ref to a map.\n  Does nothing if *report-counters* is nil."}, get-current-env {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 271, :column 7, :end-line 271, :end-column 22, :arglists (quote ([]))}, :name cljs.test/get-current-env, :variadic false, :file "out/cljs/test.cljs", :end-column 22, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 271, :end-line 271, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, file-and-line {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 399, :column 7, :end-line 399, :end-column 20, :arglists (quote ([exception depth]))}, :name cljs.test/file-and-line, :variadic false, :file "out/cljs/test.cljs", :end-column 20, :method-params ([exception depth]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 399, :end-line 399, :max-fixed-arity 2, :fn-var true, :arglists (quote ([exception depth]))}, block {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 451, :column 7, :end-line 451, :end-column 12, :arglists (quote ([fns])), :doc "Tag a seq of fns to be picked up by run-block as injected\n  continuation.  See run-block."}, :name cljs.test/block, :variadic false, :file "out/cljs/test.cljs", :end-column 12, :method-params ([fns]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 451, :end-line 451, :max-fixed-arity 1, :fn-var true, :arglists (quote ([fns])), :doc "Tag a seq of fns to be picked up by run-block as injected\n  continuation.  See run-block."}, report {:meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 318, :column 3, :end-line 318, :end-column 9, :doc "Generic reporting function, may be overridden to plug in\n   different report formats (e.g., TAP, JUnit).  Assertions such as\n   'is' call 'report' to indicate results.  The argument given to\n   'report' will be a map with a :type key.", :dynamic true}, :name cljs.test/report, :file "out/cljs/test.cljs", :end-column 9, :column 1, :dynamic true, :line 312, :end-line 318, :tag cljs.core/MultiFn, :doc "Generic reporting function, may be overridden to plug in\n   different report formats (e.g., TAP, JUnit).  Assertions such as\n   'is' call 'report' to indicate results.  The argument given to\n   'report' will be a map with a :type key."}, compose-fixtures {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 502, :column 7, :end-line 502, :end-column 23, :arglists (quote ([f1 f2])), :doc "Composes two fixture functions, creating a new fixture function\n  that combines their behavior.\n\n  NOTE: Incompatible with map fixtures."}, :name cljs.test/compose-fixtures, :variadic false, :file "out/cljs/test.cljs", :end-column 23, :method-params ([f1 f2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 502, :end-line 502, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f1 f2])), :doc "Composes two fixture functions, creating a new fixture function\n  that combines their behavior.\n\n  NOTE: Incompatible with map fixtures."}, disable-async {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 542, :column 8, :end-line 542, :end-column 21, :private true, :arglists (quote ([f]))}, :private true, :name cljs.test/disable-async, :variadic false, :file "out/cljs/test.cljs", :end-column 21, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 542, :end-line 542, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f]))}, test-var-block* {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 461, :column 8, :end-line 461, :end-column 23, :private true, :arglists (quote ([v t]))}, :private true, :name cljs.test/test-var-block*, :variadic false, :file "out/cljs/test.cljs", :end-column 23, :method-params ([v t]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 461, :end-line 461, :max-fixed-arity 2, :fn-var true, :arglists (quote ([v t]))}, js-line-and-column {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 366, :column 7, :end-line 366, :end-column 25, :arglists (quote ([stack-element]))}, :name cljs.test/js-line-and-column, :variadic false, :file "out/cljs/test.cljs", :end-column 25, :method-params ([stack-element]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 366, :end-line 366, :max-fixed-arity 1, :fn-var true, :arglists (quote ([stack-element]))}, IAsyncTest {:meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 423, :column 14, :end-line 423, :end-column 24, :doc "Marker protocol denoting CPS function to begin asynchronous\n  testing.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.test/IAsyncTest, :file "out/cljs/test.cljs", :end-column 24, :column 1, :line 423, :protocol-info {:methods {}}, :info nil, :end-line 423, :tag any, :impls #{}, :doc "Marker protocol denoting CPS function to begin asynchronous\n  testing.", :jsdoc ("@interface")}, print-comparison {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 325, :column 8, :end-line 325, :end-column 24, :private true, :arglists (quote ([m]))}, :private true, :name cljs.test/print-comparison, :variadic false, :file "out/cljs/test.cljs", :end-column 24, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 325, :end-line 325, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m]))}, test-vars-block {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 549, :column 7, :end-line 549, :end-column 22, :arglists (quote ([vars])), :doc "Like test-vars, but returns a block for further composition and\n  later execution."}, :name cljs.test/test-vars-block, :variadic false, :file "out/cljs/test.cljs", :end-column 22, :method-params ([vars]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 549, :end-line 549, :max-fixed-arity 1, :fn-var true, :arglists (quote ([vars])), :doc "Like test-vars, but returns a block for further composition and\n  later execution."}, clear-env! {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 280, :column 7, :end-line 280, :end-column 17, :arglists (quote ([]))}, :name cljs.test/clear-env!, :variadic false, :file "out/cljs/test.cljs", :end-column 17, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 280, :end-line 280, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, set-env! {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 277, :column 7, :end-line 277, :end-column 15, :arglists (quote ([new-env]))}, :name cljs.test/set-env!, :variadic false, :file "out/cljs/test.cljs", :end-column 15, :method-params ([new-env]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 277, :end-line 277, :max-fixed-arity 1, :fn-var true, :arglists (quote ([new-env]))}, wrap-map-fixtures {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 518, :column 8, :end-line 518, :end-column 25, :private true, :arglists (quote ([map-fixtures block])), :doc "Wraps block in map-fixtures."}, :private true, :name cljs.test/wrap-map-fixtures, :variadic false, :file "out/cljs/test.cljs", :end-column 25, :method-params ([map-fixtures block]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 518, :end-line 518, :max-fixed-arity 2, :fn-var true, :arglists (quote ([map-fixtures block])), :doc "Wraps block in map-fixtures."}, mapped-line-and-column {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 381, :column 7, :end-line 381, :end-column 29, :arglists (quote ([filename line column]))}, :name cljs.test/mapped-line-and-column, :variadic false, :file "out/cljs/test.cljs", :end-column 29, :method-params ([filename line column]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 381, :end-line 381, :max-fixed-arity 3, :fn-var true, :arglists (quote ([filename line column]))}, test-vars {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 582, :column 7, :end-line 582, :end-column 16, :arglists (quote ([vars])), :doc "Groups vars by their namespace and runs test-vars on them with\n  appropriate fixtures assuming they are present in the current\n  testing environment."}, :name cljs.test/test-vars, :variadic false, :file "out/cljs/test.cljs", :end-column 16, :method-params ([vars]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 582, :end-line 582, :max-fixed-arity 1, :fn-var true, :arglists (quote ([vars])), :doc "Groups vars by their namespace and runs test-vars on them with\n  appropriate fixtures assuming they are present in the current\n  testing environment."}, get-and-clear-env! {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 283, :column 7, :end-line 283, :end-column 25, :arglists (quote ([]))}, :name cljs.test/get-and-clear-env!, :variadic false, :file "out/cljs/test.cljs", :end-column 25, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 283, :end-line 283, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, test-var-block {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 482, :column 7, :end-line 482, :end-column 21, :arglists (quote ([v])), :doc "Like test-var, but returns a block for further composition and\n  later execution."}, :name cljs.test/test-var-block, :variadic false, :file "out/cljs/test.cljs", :end-column 21, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 482, :end-line 482, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "Like test-var, but returns a block for further composition and\n  later execution."}, successful? {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 594, :column 7, :end-line 594, :end-column 18, :arglists (quote ([summary])), :doc "Returns true if the given test summary indicates all tests\n  were successful, false otherwise."}, :name cljs.test/successful?, :variadic false, :file "out/cljs/test.cljs", :end-column 18, :method-params ([summary]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 594, :end-line 594, :max-fixed-arity 1, :fn-var true, :arglists (quote ([summary])), :doc "Returns true if the given test summary indicates all tests\n  were successful, false otherwise."}, empty-env {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 252, :column 7, :end-line 252, :end-column 16, :arglists (quote ([] [reporter])), :doc "Generates a testing environment with a reporter.\n   (empty-env) - uses the :cljs.test/default reporter.\n   (empty-env :cljs.test/pprint) - pretty prints all data structures. \n   (empty-env reporter) - uses a reporter of your choosing.\n\n   To create your own reporter see cljs.test/report", :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [reporter]), :arglists ([] [reporter]), :arglists-meta (nil nil)}}, :name cljs.test/empty-env, :variadic false, :file "out/cljs/test.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [reporter]), :arglists ([] [reporter]), :arglists-meta (nil nil)}, :method-params ([] [reporter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 252, :end-line 252, :max-fixed-arity 1, :fn-var true, :arglists ([] [reporter]), :doc "Generates a testing environment with a reporter.\n   (empty-env) - uses the :cljs.test/default reporter.\n   (empty-env :cljs.test/pprint) - pretty prints all data structures. \n   (empty-env reporter) - uses a reporter of your choosing.\n\n   To create your own reporter see cljs.test/report"}, testing-vars-str {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 289, :column 7, :end-line 289, :end-column 23, :arglists (quote ([m])), :doc "Returns a string representation of the current test.  Renders names\n  in *testing-vars* as a list, then the source file and line of\n  current assertion."}, :name cljs.test/testing-vars-str, :variadic false, :file "out/cljs/test.cljs", :end-column 23, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 289, :end-line 289, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Returns a string representation of the current test.  Renders names\n  in *testing-vars* as a list, then the source file and line of\n  current assertion."}, *current-env* {:name cljs.test/*current-env*, :file "out/cljs/test.cljs", :line 269, :column 1, :end-line 269, :end-column 29, :dynamic true, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 269, :column 16, :end-line 269, :end-column 29, :dynamic true}, :tag clj-nil}, run-block {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 432, :column 7, :end-line 432, :end-column 16, :arglists (quote ([fns])), :doc "Invoke all functions in fns with no arguments. A fn can optionally\n  return\n  \n  an async test - is invoked with a continuation running left fns\n\n  a seq of fns tagged per block - are invoked immediately after fn"}, :name cljs.test/run-block, :variadic false, :file "out/cljs/test.cljs", :end-column 16, :method-params ([fns]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 432, :end-line 432, :max-fixed-arity 1, :fn-var true, :arglists (quote ([fns])), :doc "Invoke all functions in fns with no arguments. A fn can optionally\n  return\n  \n  an async test - is invoked with a continuation running left fns\n\n  a seq of fns tagged per block - are invoked immediately after fn"}, update-current-env! {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 274, :column 7, :end-line 274, :end-column 26, :arglists (quote ([ks f & args])), :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(ks f args)], :arglists ([ks f & args]), :arglists-meta (nil)}}, :name cljs.test/update-current-env!, :variadic true, :file "out/cljs/test.cljs", :end-column 26, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(ks f args)], :arglists ([ks f & args]), :arglists-meta (nil)}, :method-params [(ks f args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 274, :end-line 274, :max-fixed-arity 2, :fn-var true, :arglists ([ks f & args])}, js-filename {:protocol-inline nil, :meta {:file "/Users/kennethtilton/todoFRP/todo/MatrixCLJS/out/cljs/test.cljs", :line 378, :column 7, :end-line 378, :end-column 18, :arglists (quote ([stack-element]))}, :name cljs.test/js-filename, :variadic false, :file "out/cljs/test.cljs", :end-column 18, :method-params ([stack-element]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 378, :end-line 378, :max-fixed-arity 1, :fn-var true, :arglists (quote ([stack-element]))}}, :cljs.spec/registry-ref [], :require-macros {temp clojure.template, clojure.template clojure.template, test cljs.test, cljs.test cljs.test, pprint cljs.pprint, cljs.pprint cljs.pprint}, :cljs.analyzer/constants {:seen #{:async :testing-vars :fn :begin-test-var :testing-contexts :report-counters :default :ns :name :each-fixtures :cljs.test/pprint :formatter :file :type :source :sync :cljs.test/async-disabled :column :summary :end-test-var :fail :after :reporter :line :var :end-run-tests :col :end-test-all-vars :expected :cljs.test/default :source-map :begin-test-ns :error :pass :hierarchy :actual :before :end-test-ns :map :test :cljs.test/block? :none :message :vars :once-fixtures :end-test-vars}, :order [:cljs.test/default :report-counters :testing-vars :testing-contexts :formatter :reporter :test :pass :fail :error :cljs.test/pprint :file :line :column :name :hierarchy :type :default :expected :actual :message :summary :begin-test-ns :ns :end-test-ns :begin-test-var :end-test-var :end-run-tests :end-test-all-vars :end-test-vars :source-map :source :col :cljs.test/block? :var :before :after :none :map :fn :async :sync :cljs.test/async-disabled :once-fixtures :each-fixtures :vars]}, :doc "A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the \"is\" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (= 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith \"abcde\" \"ab\"))\n\n   You can type an \"is\" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user> (is (= 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (= 5 (+ 2 2))\n         actual: (not (= 5 4))\n       false\n\n   The \"expected:\" line shows you the original expression, and the\n   \"actual:\" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not = to 5.  Finally, the\n   \"false\" on the last line is the value returned from the\n   expression.  The \"is\" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   \"(is (thrown? c ...))\" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0))) \n\n   \"(is (thrown-with-msg? c re ...))\" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #\"Divide by zero\"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   \"is\" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (= 5 (+ 2 2)) \"Crazy arithmetic\")\n\n   In addition, you can document groups of assertions with the\n   \"testing\" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to \"testing\" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec <http://rspec.info/>\n\n   (testing \"Arithmetic\"\n     (testing \"with positive integers\"\n       (is (= 4 (+ 2 2)))\n       (is (= 7 (+ 3 4))))\n     (testing \"with negative integers\"\n       (is (= -4 (+ -2 -2)))\n       (is (= -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the \"testing\" macro may only be used\n   INSIDE a \"deftest\" form (see below).\n\n\n   DEFINING TESTS\n\n   (deftest addition\n     (is (= 4 (+ 2 2)))\n     (is (= 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (= 1 (- 4 3)))\n     (is (= 3 (- 7 4))))\n\n   This creates functions named \"addition\" and \"subtraction\", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel's \"Practical Common Lisp\"\n   <http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html>\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   \"(arithmetic addition)\", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n   DEFINING ASYNC TESTS\n\n   (deftest addition\n     (async done\n       (is (= 4 (+ 2 2)))\n       (is (= 7 (+ 3 4)))\n       (done)))\n\n   Async tests are constructed with the async macro. The first argument to\n   the macro is the test completion callback. The body of the async macro may\n   be any series of expressions. The completion callback must be invoked when\n   all assertions have run. There is no support for asynchronous coordination -\n   core.async is recommended for this. Note the body of the async test must be\n   truly asynchronous to avoid stack overflow.\n\n   RUNNING TESTS\n\n   Run tests with the function \"(run-tests namespaces...)\":\n\n   (run-tests 'your.namespace 'some.other.namespace)\n\n   If you don't specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use \"(run-all-tests)\".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the \"arithmetic\" example above, you\n   probably do not want the \"addition\" and \"subtraction\" tests run\n   separately.  In that case, you must define a special function\n   named \"test-ns-hook\" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   \"run-tests\" also optionally takes a testing enviroment. A default\n   one is supplied for you by invoking \"empty-env\".  The test\n   environment contains everything needed to run tests including the\n   report results map. Fixtures must be present here if you want them\n   to run. Note that code that relies on \"test-ns\" will\n   automatically be supplied the appropriate defined fixtures.  For\n   example, this is done for you if you use \"run-tests\".\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can set the ClojureScript compiler build option\n   \":load-tests\" to false when loading or compiling code in\n   production.  This will prevent any tests from being created by\n   or \"deftest\".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is a map of one or two functions that run code before and\n   after tests.  It looks like this:\n\n   {:before (fn []\n              Perform setup, establish bindings, whatever.\n              )\n    :after (fn []\n             Tear-down / clean-up code here.\n             )}\n\n   Both are optional and can be left out.\n\n   Fixtures are attached to namespaces in one of two ways.  \"each\"\n   fixtures are run repeatedly, once for each test function created\n   with \"deftest\".  \"each\" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   \"each\" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just maps like the example above.\n   They can also be passed directly, like this:\n   (use-fixtures :each\n     {:before (fn [] setup...), :after (fn [] cleanup...)})\n\n   The other kind of fixture, a \"once\" fixture, is only run once,\n   around ALL the tests in the namespace.  \"once\" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach \"once\" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   WRAPPING FIXTURES\n\n   Instead of a map, a fixture can be specified like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   This style is incompatible with async tests. If an async test is\n   encountered, testing will be aborted. It can't be mixed with\n   fixtures specified as maps.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the \"is\" macro by defining new\n   methods for the \"assert-expr\" multimethod.  These methods are\n   called during expansion of the \"is\" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by specifying a\n   :reporter key in the test environment. It is normally set to\n   :cljs.test/default. Set this to the desired key and supply custom\n   implementations of the \"report\" multimethod.\n\n   The 'event' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to 'is'\n\n   The \"testing\" strings will be a list in the :testing-contexts\n   property of the test environment, and the vars being tested will be\n   a list in the :testing-vars property of the test environment.\n\n   For additional event types, see the examples in the code.\n"}